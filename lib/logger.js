'use strict';

/**
 * Our core logger class. Contains the logging methods, and allows you to create
 * child logs. In addition to the listed methods, there will be a method for
 * each logging level, that simply redirects to {@link Logger#log} with a set
 * `level` argument (these are generated by {@link Logger.setLevels}).
 * 
 * @class Logger
 * @param {number} level - The level to log at
 * @param {object} meta - Metadata to attach to all messages
 * @param {object} config - Additional configuration for the logger
 * @param {string} config.name - A name that we can use to retrieve our log.
 * @param {array}  config.transports - Where to send our log messages. Defaults
 *      to a new {@link Console} transport.
 */
class Logger {
    constructor(level, meta, config) {
        this.level = level;
        
        config = config || {};
        
        /**
         * The metadata to attach to all messages. Keys can be overwritten in
         * individual logs.
         * 
         * @property {object} meta
         */
        this.meta = this.mergeMeta(meta);
        
        /**
         * The name used to refer to this log in {@link module:GLog.get}, 
         * {@link module:GLog.exists}, and {@link module:GLog.remove}
         * 
         * @property {string} name
         */
        this.name = config.name || Logger.nextid();
        
        /**
         * The array of transports used by this log.
         * 
         * @property {Array<Transport>} transports
         */
        this.transports = config.transports || [new (require('./transports/console'))()];
        // this.filters = config.filters || [];
        
        Logger.logs[this.name] = this;
    }
    
    /**
     * The current logging level. Will be converted to a number when set with a string.
     * 
     * @property {number} level
     */
    get level() { return this._level; }
    set level(level) {
        if ('string' === typeof level) {
            level = Logger.levels[level];
        }
        
        this._level = isNaN(level) ? Infinity : level;
    }
    
    /**
     * Merges any number of metadata objects together.
     * 
     * @method Logger#mergeMeta
     * @return {object} The merged metadata.
     */
    mergeMeta() {
        var resultMeta = {};
        var tags = [];
        
        Array.prototype.slice.call(arguments).forEach((meta) => {
            if (meta && meta.hasOwnProperty('$tags')) {
                tags.push(meta['$tags']);
            }
            
            Object.assign(resultMeta, meta);
        });
        
        if (tags.length) {
            resultMeta['$tags'] = Array.prototype.concat.apply([], tags);
        }
        
        return resultMeta;
    }
    
    /**
     * Logs a message to the current transports if and only if Logger#level is
     * greater than or equal to `level`.
     * 
     * @method Logger#log
     * @param {string} level - The name of the current level.
     * @param {string | Error} msg - The message to be logged.
     * @param {object} logmeta - Additional metadata to be logged.
     */
    log(level, msg, logmeta) {
        if (!Logger.levels.hasOwnProperty(level)) {
            throw new Error('Invalid logging level "' + level + '"');
        }
        
        if (Logger.levels[level] > this.level) {
            return;
        }
        
        var meta = Object.assign(this.mergeMeta(this.meta, logmeta), {
            time: Date.now(),
            level: level,
            text: msg instanceof Error ? msg.message : msg
        });
        
        var json = JSON.stringify(meta);
        this.transports.forEach((transport) => {
            transport._log(json, meta);
        });
    }
    
    /**
     * Creates a new logger using all of the same settings as the parent, unless
     * modified in `config`. Also merges `meta` with the parent's metadata.
     * 
     * @method Logger#child
     * @param {number} level - The initial level to log at.
     * @param {object} meta - Permanent metadata to add to the parent's.
     * @param {object} config - Extra configuration (overwrite parent's).
     */
    child(level, meta, config) {
        if (arguments.length < 3 && 'object' === typeof level) {
            meta = level;
            level = this.level;
        }
        
        return new Logger(
            level, 
            this.mergeMeta(this.meta, meta), 
            Object.assign({
                transports: this.transports, 
                filters: this.filters 
            }, config)
        );
    }
    
    /**
     * Removes the reference to this log from {@link GLog.logs}.
     * 
     * @name Logger#remove
     */
    remove() {
        if (Logger.logs.hasOwnProperty(this.name)) {
            delete Logger.logs[this.name];
        }
    }
    
    /**
     * A set of levels in the form `name: level`. Lower level means more 
     * important (error is usually 0). This property should not be set directly,
     * instead use {@link Logger.setLevels}.
     * 
     * @name Logger.levels
     * @type {object}
     */
     
    /**
     * A container that holds all instantiated logs.
     * 
     * @name Logger.logs
     * @type {object}
     */
     
    /**
     * @name Logger._lastid
     * @type {number}
     * @private
     */
    
    /**
     * Sets the levels and creates the corresponding methods used by all logs
     * (including already instantiated ones).
     * 
     * @method Logger.setLevels
     * @param {object} levels - A set of levels in the form `name: level`. Lower
     *      level means more important (error is usually 0).
     */
    static setLevels(levels) {
        var proto = Logger.prototype;
        
        if (Logger.levels) {
            Object.keys(Logger.levels).forEach((levelName) => {
                if (proto[levelName]) {
                    delete proto[levelName];
                }
            });
        }
        
        Logger.levels = levels;
        
        Object.keys(levels).forEach((levelName) => {
            proto[levelName] = function() {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(levelName);
                
                this.log.apply(this, args);
            };
        });
    }
    
    /**
     * Returns a (usually) unique id
     * 
     * @method Logger.nextid
     * @return {number}
     */
    static nextid() {
        return Logger._lastid++;
    }
}

// Create our static properties here since JS doesn't support it in the class
// definition
Logger.logs = {};
Logger.levels = {};
Logger._lastid = 0;

// Use npm log levels
Logger.setLevels({
    error: 0,
    warn: 1,
    info: 2,
    verbose: 3,
    debug: 4,
    silly: 5
});

module.exports = Logger;
